"""aeonius

def enumFromTo:
    x -> y | x > y => []
           |       => [x] + (enumFromTo (x + 1) y)

def zip:
    []       -> _        => []
    [h1,*t1] -> []       => []
                [h2,*t2] => [(h1,h2)] + (zip t1 t2)

def group:
    []      => []
    [h]     => [[h]]
    [h, *t] => 
        [[h,h1,*t1],*t2] if h == h1 else [[h],[h1,*t1],*t2]
        [[h1, *t1],*t2] = group t


def replicate:
    0 -> _ => []
    n -> a => [a] + (replicate (n - 1) a)

def elem:
    x -> []               => False
         [h, *t] | h == x => True
                 |        => elem x t


def union:
    a -> b => a + (ae_filter (negate . ((flip elem) a)) b)

def intersect:
    a -> b => ae_filter ((flip elem) b) a
    
def intersperce:
    x -> []      => []
         [h]     => [h]
         [h, *t] => [h,x] + (intersperce x t) 

#13
def concat:
    []     => []
    [h,*t] => h + (concat t)

unwords = concat . intersperce " "
unlines = concat . intersperce "\n"

algarismos = ae_filter is_number

vertical = lambda l: length (ae_filter (lambda y: elem y (["Oeste", "Este"])) l) == 0

def elemMSet:
    a -> []         => False
         [(b,_),*t] | a == b => True
                    |        => elemMSet a t
         [_,*t]     => elemMSet a t

def lengthMSet:
    []         => 0
    [(_,x),*t] => x + (lengthMSet t)

def menor:
    []     -> [] => False
              _  => True
    [h,*t] -> []                                => False
              [h1,*t1] | (ascii h) > (ascii h1) => False
                       | (ascii h) < (ascii h1) => True
                       |                        => menor t t1

def elemIndices:
    x -> l => 
            ae_map snd (ae_filter (lambda y: (fst y) == x) (zip l l1))
            n = length l
            l1 = enumFromTo 0 (n - 1)

def insereMSet:
    a -> []         => [(a,1)]
         [(b,x),*t] | a == b => [(a,x + 1),*t]
                    |        => [(b,x)] + (insereMSet a t) 
         [h,*t]     => [h] + insereMSet a t

def removeMSet:
    a -> [] => []
         [(b,x),*t] | a == b => t if x == 1 else [(a, x - 1), *t]
                    |        => [(b,x)] + (removeMSet a t)
         [h,*t] => [h] + (removeMSet a t)
         
constroiMSet = ae_map ((head >< length) . dup) . group

def interseccaoOk:
    l => length (ae_filter (negate . (lambda s: s == "Vermelho")) l) <= 1


def nub:
    []     => []
    [h,*t] => 
        n if (elem h n) else ([h] + n)
        n = nub t
    

temRepetidos = lambda x: x == (nub x)

def menor:
    []     -> [] => False
              _  => True
    [h,*t] -> []                                => False
              [h1,*t1] | (ascii h) > (ascii h1) => False
                       | (ascii h) < (ascii h1) => True
                       |                        => menor t t1

pMaior = head . (uncurry elemIndices) . (maximum >< id) . dup

def maisCentral:
   [h] => h
   [(x,y),*t] =>
       (x,y) if d <= d1 else (x1,y1)
       (x1,y1) = maisCentral t
       d1 = (x1 ^ 2) + (y1 ^ 2)
       d = (x ^ 2) + (y ^ 2)
"""

print(maisCentral([(2,5), (2,4)]))
#print(vizinhos({"x": 1, "y": 3})([{"x": 1, "y": 3}, {"x": 1, "y": 4}, {"x": 3, "y": 3}])